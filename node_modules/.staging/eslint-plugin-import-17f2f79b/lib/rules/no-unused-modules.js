'use strict';





var _ExportMap = require('../ExportMap');var _ExportMap2 = _interopRequireDefault(_ExportMap);
var _ignore = require('eslint-module-utils/ignore');
var _resolve = require('eslint-module-utils/resolve');var _resolve2 = _interopRequireDefault(_resolve);
var _docsUrl = require('../docsUrl');var _docsUrl2 = _interopRequireDefault(_docsUrl);
var _path = require('path');
var _readPkgUp = require('read-pkg-up');var _readPkgUp2 = _interopRequireDefault(_readPkgUp);
var _object = require('object.values');var _object2 = _interopRequireDefault(_object);
var _arrayIncludes = require('array-includes');var _arrayIncludes2 = _interopRequireDefault(_arrayIncludes);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _toConsumableArray(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];return arr2;} else {return Array.from(arr);}} /**
                                                                                                                                                                                                                                                                                                                                                                                                   * @fileOverview Ensures that modules contain exports and/or all
                                                                                                                                                                                                                                                                                                                                                                                                   * modules are consumed within other modules.
                                                                                                                                                                                                                                                                                                                                                                                                   * @author RenÃ© Fermann
                                                                                                                                                                                                                                                                                                                                                                                                   */ // eslint/lib/util/glob-util has been moved to eslint/lib/util/glob-utils with version 5.3
// and has been moved to eslint/lib/cli-engine/file-enumerator in version 6
let listFilesToProcess;try {const FileEnumerator = require('eslint/lib/cli-engine/file-enumerator').FileEnumerator;
  listFilesToProcess = function (src, extensions) {
    const e = new FileEnumerator({
      extensions: extensions });

    return Array.from(e.iterateFiles(src), (_ref) => {let filePath = _ref.filePath,ignored = _ref.ignored;return {
        ignored,
        filename: filePath };});

  };
} catch (e1) {
  // Prevent passing invalid options (extensions array) to old versions of the function.
  // https://github.com/eslint/eslint/blob/v5.16.0/lib/util/glob-utils.js#L178-L280
  // https://github.com/eslint/eslint/blob/v5.2.0/lib/util/glob-util.js#L174-L269
  let originalListFilesToProcess;
  try {
    originalListFilesToProcess = require('eslint/lib/util/glob-utils').listFilesToProcess;
    listFilesToProcess = function (src, extensions) {
      return originalListFilesToProcess(src, {
        extensions: extensions });

    };
  } catch (e2) {
    originalListFilesToProcess = require('eslint/lib/util/glob-util').listFilesToProcess;

    listFilesToProcess = function (src, extensions) {
      const patterns = src.reduce((carry, pattern) => {
        return carry.concat(extensions.map(extension => {
          return (/\*\*|\*\./.test(pattern) ? pattern : `${pattern}/**/*${extension}`);
        }));
      }, src.slice());

      return originalListFilesToProcess(patterns);
    };
  }
}

const EXPORT_DEFAULT_DECLARATION = 'ExportDefaultDeclaration';
const EXPORT_NAMED_DECLARATION = 'ExportNamedDeclaration';
const EXPORT_ALL_DECLARATION = 'ExportAllDeclaration';
const IMPORT_DECLARATION = 'ImportDeclaration';
const IMPORT_NAMESPACE_SPECIFIER = 'ImportNamespaceSpecifier';
const IMPORT_DEFAULT_SPECIFIER = 'ImportDefaultSpecifier';
const VARIABLE_DECLARATION = 'VariableDeclaration';
const FUNCTION_DECLARATION = 'FunctionDeclaration';
const CLASS_DECLARATION = 'ClassDeclaration';
const INTERFACE_DECLARATION = 'InterfaceDeclaration';
const TYPE_ALIAS = 'TypeAlias';
const TS_INTERFACE_DECLARATION = 'TSInterfaceDeclaration';
const TS_TYPE_ALIAS_DECLARATION = 'TSTypeAliasDeclaration';
const TS_ENUM_DECLARATION = 'TSEnumDeclaration';
const DEFAULT = 'default';

function forEachDeclarationIdentifier(declaration, cb) {
  if (declaration) {
    if (
    declaration.type === FUNCTION_DECLARATION ||
    declaration.type === CLASS_DECLARATION ||
    declaration.type === INTERFACE_DECLARATION ||
    declaration.type === TYPE_ALIAS ||
    declaration.type === TS_INTERFACE_DECLARATION ||
    declaration.type === TS_TYPE_ALIAS_DECLARATION ||
    declaration.type === TS_ENUM_DECLARATION)
    {
      cb(declaration.id.name);
    } else if (declaration.type === VARIABLE_DECLARATION) {
      declaration.declarations.forEach((_ref2) => {let id = _ref2.id;
        cb(id.name);
      });
    }
  }
}

/**
   * List of imports per file.
   *
   * Represented by a two-level Map to a Set of identifiers. The upper-level Map
   * keys are the paths to the modules containing the imports, while the
   * lower-level Map keys are the paths to the files which are being imported
   * from. Lastly, the Set of identifiers contains either names being imported
   * or a special AST node name listed above (e.g ImportDefaultSpecifier).
   *
   * For example, if we have a file named foo.js containing:
   *
   *   import { o2 } from './bar.js';
   *
   * Then we will have a structure that looks like:
   *
   *   Map { 'foo.js' => Map { 'bar.js' => Set { 'o2' } } }
   *
   * @type {Map<string, Map<string, Set<string>>>}
   */
const importList = new Map();

/**
                               * List of exports per file.
                               *
                               * Represented by a two-level Map to an object of metadata. The upper-level Map
                               * keys are the paths to the modules containing the exports, while the
                               * lower-level Map keys are the specific identifiers or special AST node names
                               * being exported. The leaf-level metadata object at the moment only contains a
                               * `whereUsed` propoerty, which contains a Set of paths to modules that import
                               * the name.
                               *
                               * For example, if we have a file named bar.js containing the following exports:
                               *
                               *   const o2 = 'bar';
                               *   export { o2 };
                               *
                               * And a file named foo.js containing the following import:
                               *
                               *   import { o2 } from './bar.js';
                               *
                               * Then we will have a structure that looks like:
                               *
                               *   Map { 'bar.js' => Map { 'o2' => { whereUsed: Set { 'foo.js' } } } }
                               *
                               * @type {Map<string, Map<string, object>>}
                               */
const exportList = new Map();

const ignoredFiles = new Set();
const filesOutsideSrc = new Set();

const isNodeModule = path => {
  return (/\/(node_modules)\//.test(path));
};

/**
    * read all files matching the patterns in src and ignoreExports
    *
    * return all files matching src pattern, which are not matching the ignoreExports pattern
    */
const resolveFiles = (src, ignoreExports, context) => {
  const extensions = Array.from((0, _ignore.getFileExtensions)(context.settings));

  const srcFiles = new Set();
  const srcFileList = listFilesToProcess(src, extensions);

  // prepare list of ignored files
  const ignoredFilesList = listFilesToProcess(ignoreExports, extensions);
  ignoredFilesList.forEach((_ref3) => {let filename = _ref3.filename;return ignoredFiles.add(filename);});

  // prepare list of source files, don't consider files from node_modules
  srcFileList.filter((_ref4) => {let filename = _ref4.filename;return !isNodeModule(filename);}).forEach((_ref5) => {let filename = _ref5.filename;
    srcFiles.add(filename);
  });
  return srcFiles;
};

/**
    * parse all source files and build up 2 maps containing the existing imports and exports
    */
const prepareImportsAndExports = (srcFiles, context) => {
  const exportAll = new Map();
  srcFiles.forEach(file => {
    const exports = new Map();
    const imports = new Map();
    const currentExports = _ExportMap2.default.get(file, context);
    if (currentExports) {const
      dependencies = currentExports.dependencies,reexports = currentExports.reexports,localImportList = currentExports.imports,namespace = currentExports.namespace;

      // dependencies === export * from
      const currentExportAll = new Set();
      dependencies.forEach(getDependency => {
        const dependency = getDependency();
        if (dependency === null) {
          return;
        }

        currentExportAll.add(dependency.path);
      });
      exportAll.set(file, currentExportAll);

      reexports.forEach((value, key) => {
        if (key === DEFAULT) {
          exports.set(IMPORT_DEFAULT_SPECIFIER, { whereUsed: new Set() });
        } else {
          exports.set(key, { whereUsed: new Set() });
        }
        const reexport = value.getImport();
        if (!reexport) {
          return;
        }
        let localImport = imports.get(reexport.path);
        let currentValue;
        if (value.local === DEFAULT) {
          currentValue = IMPORT_DEFAULT_SPECIFIER;
        } else {
          currentValue = value.local;
        }
        if (typeof localImport !== 'undefined') {
          localImport = new Set([].concat(_toConsumableArray(localImport), [currentValue]));
        } else {
          localImport = new Set([currentValue]);
        }
        imports.set(reexport.path, localImport);
      });

      localImportList.forEach((value, key) => {
        if (isNodeModule(key)) {
          return;
        }
        let localImport = imports.get(key);
        if (typeof localImport !== 'undefined') {
          localImport = new Set([].concat(_toConsumableArray(localImport), _toConsumableArray(value.importedSpecifiers)));
        } else {
          localImport = value.importedSpecifiers;
        }
        imports.set(key, localImport);
      });
      importList.set(file, imports);

      // build up export list only, if file is not ignored
      if (ignoredFiles.has(file)) {
        return;
      }
      namespace.forEach((value, key) => {
        if (key === DEFAULT) {
          exports.set(IMPORT_DEFAULT_SPECIFIER, { whereUsed: new Set() });
        } else {
          exports.set(key, { whereUsed: new Set() });
        }
      });
    }
    exports.set(EXPORT_ALL_DECLARATION, { whereUsed: new Set() });
    exports.set(IMPORT_NAMESPACE_SPECIFIER, { whereUsed: new Set() });
    exportList.set(file, exports);
  });
  exportAll.forEach((value, key) => {
    value.forEach(val => {
      const currentExports = exportList.get(val);
      const currentExport = currentExports.get(EXPORT_ALL_DECLARATION);
      currentExport.whereUsed.add(key);
    });
  });
};

/**
    * traverse through all imports and add the respective path to the whereUsed-list
    * of the corresponding export
    */
const determineUsage = () => {
  importList.forEach((listValue, listKey) => {
    listValue.forEach((value, key) => {
      const exports = exportList.get(key);
      if (typeof exports !== 'undefined') {
        value.forEach(currentImport => {
          let specifier;
          if (currentImport === IMPORT_NAMESPACE_SPECIFIER) {
            specifier = IMPORT_NAMESPACE_SPECIFIER;
          } else if (currentImport === IMPORT_DEFAULT_SPECIFIER) {
            specifier = IMPORT_DEFAULT_SPECIFIER;
          } else {
            specifier = currentImport;
          }
          if (typeof specifier !== 'undefined') {
            const exportStatement = exports.get(specifier);
            if (typeof exportStatement !== 'undefined') {const
              whereUsed = exportStatement.whereUsed;
              whereUsed.add(listKey);
              exports.set(specifier, { whereUsed });
            }
          }
        });
      }
    });
  });
};

const getSrc = src => {
  if (src) {
    return src;
  }
  return [process.cwd()];
};

/**
    * prepare the lists of existing imports and exports - should only be executed once at
    * the start of a new eslint run
    */
let srcFiles;
let lastPrepareKey;
const doPreparation = (src, ignoreExports, context) => {
  const prepareKey = JSON.stringify({
    src: (src || []).sort(),
    ignoreExports: (ignoreExports || []).sort(),
    extensions: Array.from((0, _ignore.getFileExtensions)(context.settings)).sort() });

  if (prepareKey === lastPrepareKey) {
    return;
  }

  importList.clear();
  exportList.clear();
  ignoredFiles.clear();
  filesOutsideSrc.clear();

  srcFiles = resolveFiles(getSrc(src), ignoreExports, context);
  prepareImportsAndExports(srcFiles, context);
  determineUsage();
  lastPrepareKey = prepareKey;
};

const newNamespaceImportExists = specifiers =>
specifiers.some((_ref6) => {let type = _ref6.type;return type === IMPORT_NAMESPACE_SPECIFIER;});

const newDefaultImportExists = specifiers =>
specifiers.some((_ref7) => {let type = _ref7.type;return type === IMPORT_DEFAULT_SPECIFIER;});

const fileIsInPkg = file => {var _readPkgUp$sync =
  _readPkgUp2.default.sync({ cwd: file, normalize: false });const path = _readPkgUp$sync.path,pkg = _readPkgUp$sync.pkg;
  const basePath = (0, _path.dirname)(path);

  const checkPkgFieldString = pkgField => {
    if ((0, _path.join)(basePath, pkgField) === file) {
      return true;
    }
  };

  const checkPkgFieldObject = pkgField => {
    const pkgFieldFiles = (0, _object2.default)(pkgField).map(value => (0, _path.join)(basePath, value));
    if ((0, _arrayIncludes2.default)(pkgFieldFiles, file)) {
      return true;
    }
  };

  const checkPkgField = pkgField => {
    if (typeof pkgField === 'string') {
      return checkPkgFieldString(pkgField);
    }

    if (typeof pkgField === 'object') {
      return checkPkgFieldObject(pkgField);
    }
  };

  if (pkg.private === true) {
    return false;
  }

  if (pkg.bin) {
    if (checkPkgField(pkg.bin)) {
      return true;
    }
  }

  if (pkg.browser) {
    if (checkPkgField(pkg.browser)) {
      return true;
    }
  }

  if (pkg.main) {
    if (checkPkgFieldString(pkg.main)) {
      return true;
    }
  }

  return false;
};

module.exports = {
  meta: {
    type: 'suggestion',
    docs: { url: (0, _docsUrl2.default)('no-unused-modules') },
    schema: [{
      properties: {
        src: {
          description: 'files/paths to be analyzed (only for unused exports)',
          type: 'array',
          minItems: 1,
          items: {
            type: 'string',
            minLength: 1 } },


        ignoreExports: {
          description:
          'files/paths for which unused exports will not be reported (e.g module entry points)',
          type: 'array',
          minItems: 1,
          items: {
            type: 'string',
            minLength: 1 } },


        missingExports: {
          description: 'report modules without any exports',
          type: 'boolean' },

        unusedExports: {
          description: 'report exports without any usage',
          type: 'boolean' } },


      not: {
        properties: {
          unusedExports: { enum: [false] },
          missingExports: { enum: [false] } } },


      anyOf: [{
        not: {
          properties: {
            unusedExports: { enum: [true] } } },


        required: ['missingExports'] },
      {
        not: {
          properties: {
            missingExports: { enum: [true] } } },


        required: ['unusedExports'] },
      {
        properties: {
          unusedExports: { enum: [true] } },

        required: ['unusedExports'] },
      {
        properties: {
          missingExports: { enum: [true] } },

        required: ['missingExports'] }] }] },




  create: context => {var _ref8 =





    context.options[0] || {};const src = _ref8.src;var _ref8$ignoreExports = _ref8.ignoreExports;const ignoreExports = _ref8$ignoreExports === undefined ? [] : _ref8$ignoreExports,missingExports = _ref8.missingExports,unusedExports = _ref8.unusedExports;

    if (unusedExports) {
      doPreparation(src, ignoreExports, context);
    }

    const file = context.getFilename();

    const checkExportPresence = node => {
      if (!missingExports) {
        return;
      }

      if (ignoredFiles.has(file)) {
        return;
      }

      const exportCount = exportList.get(file);
      const exportAll = exportCount.get(EXPORT_ALL_DECLARATION);
      const namespaceImports = exportCount.get(IMPORT_NAMESPACE_SPECIFIER);

      exportCount.delete(EXPORT_ALL_DECLARATION);
      exportCount.delete(IMPORT_NAMESPACE_SPECIFIER);
      if (exportCount.size < 1) {
        // node.body[0] === 'undefined' only happens, if everything is commented out in the file
        // being linted
        context.report(node.body[0] ? node.body[0] : node, 'No exports found');
      }
      exportCount.set(EXPORT_ALL_DECLARATION, exportAll);
      exportCount.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);
    };

    const checkUsage = (node, exportedValue) => {
      if (!unusedExports) {
        return;
      }

      if (ignoredFiles.has(file)) {
        return;
      }

      if (fileIsInPkg(file)) {
        return;
      }

      if (filesOutsideSrc.has(file)) {
        return;
      }

      // make sure file to be linted is included in source files
      if (!srcFiles.has(file)) {
        srcFiles = resolveFiles(getSrc(src), ignoreExports, context);
        if (!srcFiles.has(file)) {
          filesOutsideSrc.add(file);
          return;
        }
      }

      exports = exportList.get(file);

      // special case: export * from
      const exportAll = exports.get(EXPORT_ALL_DECLARATION);
      if (typeof exportAll !== 'undefined' && exportedValue !== IMPORT_DEFAULT_SPECIFIER) {
        if (exportAll.whereUsed.size > 0) {
          return;
        }
      }

      // special case: namespace import
      const namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);
      if (typeof namespaceImports !== 'undefined') {
        if (namespaceImports.whereUsed.size > 0) {
          return;
        }
      }

      // exportsList will always map any imported value of 'default' to 'ImportDefaultSpecifier'
      const exportsKey = exportedValue === DEFAULT ? IMPORT_DEFAULT_SPECIFIER : exportedValue;

      const exportStatement = exports.get(exportsKey);

      const value = exportsKey === IMPORT_DEFAULT_SPECIFIER ? DEFAULT : exportsKey;

      if (typeof exportStatement !== 'undefined') {
        if (exportStatement.whereUsed.size < 1) {
          context.report(
          node,
          `exported declaration '${value}' not used within other modules`);

        }
      } else {
        context.report(
        node,
        `exported declaration '${value}' not used within other modules`);

      }
    };

    /**
        * only useful for tools like vscode-eslint
        *
        * update lists of existing exports during runtime
        */
    const updateExportUsage = node => {
      if (ignoredFiles.has(file)) {
        return;
      }

      let exports = exportList.get(file);

      // new module has been created during runtime
      // include it in further processing
      if (typeof exports === 'undefined') {
        exports = new Map();
      }

      const newExports = new Map();
      const newExportIdentifiers = new Set();

      node.body.forEach((_ref9) => {let type = _ref9.type,declaration = _ref9.declaration,specifiers = _ref9.specifiers;
        if (type === EXPORT_DEFAULT_DECLARATION) {
          newExportIdentifiers.add(IMPORT_DEFAULT_SPECIFIER);
        }
        if (type === EXPORT_NAMED_DECLARATION) {
          if (specifiers.length > 0) {
            specifiers.forEach(specifier => {
              if (specifier.exported) {
                newExportIdentifiers.add(specifier.exported.name);
              }
            });
          }
          forEachDeclarationIdentifier(declaration, name => {
            newExportIdentifiers.add(name);
          });
        }
      });

      // old exports exist within list of new exports identifiers: add to map of new exports
      exports.forEach((value, key) => {
        if (newExportIdentifiers.has(key)) {
          newExports.set(key, value);
        }
      });

      // new export identifiers added: add to map of new exports
      newExportIdentifiers.forEach(key => {
        if (!exports.has(key)) {
          newExports.set(key, { whereUsed: new Set() });
        }
      });

      // preserve information about namespace imports
      let exportAll = exports.get(EXPORT_ALL_DECLARATION);
      let namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);

      if (typeof namespaceImports === 'undefined') {
        namespaceImports = { whereUsed: new Set() };
      }

      newExports.set(EXPORT_ALL_DECLARATION, exportAll);
      newExports.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);
      exportList.set(file, newExports);
    };

    /**
        * only useful for tools like vscode-eslint
        *
        * update lists of existing imports during runtime
        */
    const updateImportUsage = node => {
      if (!unusedExports) {
        return;
      }

      let oldImportPaths = importList.get(file);
      if (typeof oldImportPaths === 'undefined') {
        oldImportPaths = new Map();
      }

      const oldNamespaceImports = new Set();
      const newNamespaceImports = new Set();

      const oldExportAll = new Set();
      const newExportAll = new Set();

      const oldDefaultImports = new Set();
      const newDefaultImports = new Set();

      const oldImports = new Map();
      const newImports = new Map();
      oldImportPaths.forEach((value, key) => {
        if (value.has(EXPORT_ALL_DECLARATION)) {
          oldExportAll.add(key);
        }
        if (value.has(IMPORT_NAMESPACE_SPECIFIER)) {
          oldNamespaceImports.add(key);
        }
        if (value.has(IMPORT_DEFAULT_SPECIFIER)) {
          oldDefaultImports.add(key);
        }
        value.forEach(val => {
          if (val !== IMPORT_NAMESPACE_SPECIFIER &&
          val !== IMPORT_DEFAULT_SPECIFIER) {
            oldImports.set(val, key);
          }
        });
      });

      node.body.forEach(astNode => {
        let resolvedPath;

        // support for export { value } from 'module'
        if (astNode.type === EXPORT_NAMED_DECLARATION) {
          if (astNode.source) {
            resolvedPath = (0, _resolve2.default)(astNode.source.raw.replace(/('|")/g, ''), context);
            astNode.specifiers.forEach(specifier => {
              const name = specifier.local.name;
              if (specifier.local.name === DEFAULT) {
                newDefaultImports.add(resolvedPath);
              } else {
                newImports.set(name, resolvedPath);
              }
            });
          }
        }

        if (astNode.type === EXPORT_ALL_DECLARATION) {
          resolvedPath = (0, _resolve2.default)(astNode.source.raw.replace(/('|")/g, ''), context);
          newExportAll.add(resolvedPath);
        }

        if (astNode.type === IMPORT_DECLARATION) {
          resolvedPath = (0, _resolve2.default)(astNode.source.raw.replace(/('|")/g, ''), context);
          if (!resolvedPath) {
            return;
          }

          if (isNodeModule(resolvedPath)) {
            return;
          }

          if (newNamespaceImportExists(astNode.specifiers)) {
            newNamespaceImports.add(resolvedPath);
          }

          if (newDefaultImportExists(astNode.specifiers)) {
            newDefaultImports.add(resolvedPath);
          }

          astNode.specifiers.forEach(specifier => {
            if (specifier.type === IMPORT_DEFAULT_SPECIFIER ||
            specifier.type === IMPORT_NAMESPACE_SPECIFIER) {
              return;
            }
            newImports.set(specifier.imported.name, resolvedPath);
          });
        }
      });

      newExportAll.forEach(value => {
        if (!oldExportAll.has(value)) {
          let imports = oldImportPaths.get(value);
          if (typeof imports === 'undefined') {
            imports = new Set();
          }
          imports.add(EXPORT_ALL_DECLARATION);
          oldImportPaths.set(value, imports);

          let exports = exportList.get(value);
          let currentExport;
          if (typeof exports !== 'undefined') {
            currentExport = exports.get(EXPORT_ALL_DECLARATION);
          } else {
            exports = new Map();
            exportList.set(value, exports);
          }

          if (typeof currentExport !== 'undefined') {
            currentExport.whereUsed.add(file);
          } else {
            const whereUsed = new Set();
            whereUsed.add(file);
            exports.set(EXPORT_ALL_DECLARATION, { whereUsed });
          }
        }
      });

      oldExportAll.forEach(value => {
        if (!newExportAll.has(value)) {
          const imports = oldImportPaths.get(value);
          imports.delete(EXPORT_ALL_DECLARATION);

          const exports = exportList.get(value);
          if (typeof exports !== 'undefined') {
            const currentExport = exports.get(EXPORT_ALL_DECLARATION);
            if (typeof currentExport !== 'undefined') {
              currentExport.whereUsed.delete(file);
            }
          }
        }
      });

      newDefaultImports.forEach(value => {
        if (!oldDefaultImports.has(value)) {
          let imports = oldImportPaths.get(value);
          if (typeof imports === 'undefined') {
            imports = new Set();
          }
          imports.add(IMPORT_DEFAULT_SPECIFIER);
          oldImportPaths.set(value, imports);

          let exports = exportList.get(value);
          let currentExport;
          if (typeof exports !== 'undefined') {
            currentExport = exports.get(IMPORT_DEFAULT_SPECIFIER);
          } else {
            exports = new Map();
            exportList.set(value, exports);
          }

          if (typeof currentExport !== 'undefined') {
            currentExport.whereUsed.add(file);
          } else {
            const whereUsed = new Set();
            whereUsed.add(file);
            exports.set(IMPORT_DEFAULT_SPECIFIER, { whereUsed });
          }
        }
      });

      oldDefaultImports.forEach(value => {
        if (!newDefaultImports.has(value)) {
          const imports = oldImportPaths.get(value);
          imports.delete(IMPORT_DEFAULT_SPECIFIER);

          const exports = exportList.get(value);
          if (typeof exports !== 'undefined') {
            const currentExport = exports.get(IMPORT_DEFAULT_SPECIFIER);
            if (typeof currentExport !== 'undefined') {
              currentExport.whereUsed.delete(file);
            }
          }
        }
      });

      newNamespaceImports.forEach(value => {
        if (!oldNamespaceImports.has(value)) {
          let imports = oldImportPaths.get(value);
          if (typeof imports === 'undefined') {
            imports = new Set();
          }
          imports.add(IMPORT_NAMESPACE_SPECIFIER);
          oldImportPaths.set(value, imports);

          let exports = exportList.get(value);
          let currentExport;
          if (typeof exports !== 'undefined') {
            currentExport = exports.get(IMPORT_NAMESPACE_SPECIFIER);
          } else {
            exports = new Map();
            exportList.set(value, exports);
          }

          if (typeof currentExport !== 'undefined') {
            currentExport.whereUsed.add(file);
          } else {
            const whereUsed = new Set();
            whereUsed.add(file);
            exports.set(IMPORT_NAMESPACE_SPECIFIER, { whereUsed });
          }
        }
      });

      oldNamespaceImports.forEach(value => {
        if (!newNamespaceImports.has(value)) {
          const imports = oldImportPaths.get(value);
          imports.delete(IMPORT_NAMESPACE_SPECIFIER);

          const exports = exportList.get(value);
          if (typeof exports !== 'undefined') {
            const currentExport = exports.get(IMPORT_NAMESPACE_SPECIFIER);
            if (typeof currentExport !== 'undefined') {
              currentExport.whereUsed.delete(file);
            }
          }
        }
      });

      newImports.forEach((value, key) => {
        if (!oldImports.has(key)) {
          let imports = oldImportPaths.get(value);
          if (typeof imports === 'undefined') {
            imports = new Set();
          }
          imports.add(key);
          oldImportPaths.set(value, imports);

          let exports = exportList.get(value);
          let currentExport;
          if (typeof exports !== 'undefined') {
            currentExport = exports.get(key);
          } else {
            exports = new Map();
            exportList.set(value, exports);
          }

          if (typeof currentExport !== 'undefined') {
            currentExport.whereUsed.add(file);
          } else {
            const whereUsed = new Set();
            whereUsed.add(file);
            exports.set(key, { whereUsed });
          }
        }
      });

      oldImports.forEach((value, key) => {
        if (!newImports.has(key)) {
          const imports = oldImportPaths.get(value);
          imports.delete(key);

          const exports = exportList.get(value);
          if (typeof exports !== 'undefined') {
            const currentExport = exports.get(key);
            if (typeof currentExport !== 'undefined') {
              currentExport.whereUsed.delete(file);
            }
          }
        }
      });
    };

    return {
      'Program:exit': node => {
        updateExportUsage(node);
        updateImportUsage(node);
        checkExportPresence(node);
      },
      'ExportDefaultDeclaration': node => {
        checkUsage(node, IMPORT_DEFAULT_SPECIFIER);
      },
      'ExportNamedDeclaration': node => {
        node.specifiers.forEach(specifier => {
          checkUsage(node, specifier.exported.name);
        });
        forEachDeclarationIdentifier(node.declaration, name => {
          checkUsage(node, name);
        });
      } };

  } };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9uby11bnVzZWQtbW9kdWxlcy5qcyJdLCJuYW1lcyI6WyJsaXN0RmlsZXNUb1Byb2Nlc3MiLCJGaWxlRW51bWVyYXRvciIsInJlcXVpcmUiLCJzcmMiLCJleHRlbnNpb25zIiwiZSIsIkFycmF5IiwiZnJvbSIsIml0ZXJhdGVGaWxlcyIsImZpbGVQYXRoIiwiaWdub3JlZCIsImZpbGVuYW1lIiwiZTEiLCJvcmlnaW5hbExpc3RGaWxlc1RvUHJvY2VzcyIsImUyIiwicGF0dGVybnMiLCJyZWR1Y2UiLCJjYXJyeSIsInBhdHRlcm4iLCJjb25jYXQiLCJtYXAiLCJleHRlbnNpb24iLCJ0ZXN0Iiwic2xpY2UiLCJFWFBPUlRfREVGQVVMVF9ERUNMQVJBVElPTiIsIkVYUE9SVF9OQU1FRF9ERUNMQVJBVElPTiIsIkVYUE9SVF9BTExfREVDTEFSQVRJT04iLCJJTVBPUlRfREVDTEFSQVRJT04iLCJJTVBPUlRfTkFNRVNQQUNFX1NQRUNJRklFUiIsIklNUE9SVF9ERUZBVUxUX1NQRUNJRklFUiIsIlZBUklBQkxFX0RFQ0xBUkFUSU9OIiwiRlVOQ1RJT05fREVDTEFSQVRJT04iLCJDTEFTU19ERUNMQVJBVElPTiIsIklOVEVSRkFDRV9ERUNMQVJBVElPTiIsIlRZUEVfQUxJQVMiLCJUU19JTlRFUkZBQ0VfREVDTEFSQVRJT04iLCJUU19UWVBFX0FMSUFTX0RFQ0xBUkFUSU9OIiwiVFNfRU5VTV9ERUNMQVJBVElPTiIsIkRFRkFVTFQiLCJmb3JFYWNoRGVjbGFyYXRpb25JZGVudGlmaWVyIiwiZGVjbGFyYXRpb24iLCJjYiIsInR5cGUiLCJpZCIsIm5hbWUiLCJkZWNsYXJhdGlvbnMiLCJmb3JFYWNoIiwiaW1wb3J0TGlzdCIsIk1hcCIsImV4cG9ydExpc3QiLCJpZ25vcmVkRmlsZXMiLCJTZXQiLCJmaWxlc091dHNpZGVTcmMiLCJpc05vZGVNb2R1bGUiLCJwYXRoIiwicmVzb2x2ZUZpbGVzIiwiaWdub3JlRXhwb3J0cyIsImNvbnRleHQiLCJzZXR0aW5ncyIsInNyY0ZpbGVzIiwic3JjRmlsZUxpc3QiLCJpZ25vcmVkRmlsZXNMaXN0IiwiYWRkIiwiZmlsdGVyIiwicHJlcGFyZUltcG9ydHNBbmRFeHBvcnRzIiwiZXhwb3J0QWxsIiwiZmlsZSIsImV4cG9ydHMiLCJpbXBvcnRzIiwiY3VycmVudEV4cG9ydHMiLCJFeHBvcnRzIiwiZ2V0IiwiZGVwZW5kZW5jaWVzIiwicmVleHBvcnRzIiwibG9jYWxJbXBvcnRMaXN0IiwibmFtZXNwYWNlIiwiY3VycmVudEV4cG9ydEFsbCIsImdldERlcGVuZGVuY3kiLCJkZXBlbmRlbmN5Iiwic2V0IiwidmFsdWUiLCJrZXkiLCJ3aGVyZVVzZWQiLCJyZWV4cG9ydCIsImdldEltcG9ydCIsImxvY2FsSW1wb3J0IiwiY3VycmVudFZhbHVlIiwibG9jYWwiLCJpbXBvcnRlZFNwZWNpZmllcnMiLCJoYXMiLCJ2YWwiLCJjdXJyZW50RXhwb3J0IiwiZGV0ZXJtaW5lVXNhZ2UiLCJsaXN0VmFsdWUiLCJsaXN0S2V5IiwiY3VycmVudEltcG9ydCIsInNwZWNpZmllciIsImV4cG9ydFN0YXRlbWVudCIsImdldFNyYyIsInByb2Nlc3MiLCJjd2QiLCJsYXN0UHJlcGFyZUtleSIsImRvUHJlcGFyYXRpb24iLCJwcmVwYXJlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNvcnQiLCJjbGVhciIsIm5ld05hbWVzcGFjZUltcG9ydEV4aXN0cyIsInNwZWNpZmllcnMiLCJzb21lIiwibmV3RGVmYXVsdEltcG9ydEV4aXN0cyIsImZpbGVJc0luUGtnIiwicmVhZFBrZ1VwIiwic3luYyIsIm5vcm1hbGl6ZSIsInBrZyIsImJhc2VQYXRoIiwiY2hlY2tQa2dGaWVsZFN0cmluZyIsInBrZ0ZpZWxkIiwiY2hlY2tQa2dGaWVsZE9iamVjdCIsInBrZ0ZpZWxkRmlsZXMiLCJjaGVja1BrZ0ZpZWxkIiwicHJpdmF0ZSIsImJpbiIsImJyb3dzZXIiLCJtYWluIiwibW9kdWxlIiwibWV0YSIsImRvY3MiLCJ1cmwiLCJzY2hlbWEiLCJwcm9wZXJ0aWVzIiwiZGVzY3JpcHRpb24iLCJtaW5JdGVtcyIsIml0ZW1zIiwibWluTGVuZ3RoIiwibWlzc2luZ0V4cG9ydHMiLCJ1bnVzZWRFeHBvcnRzIiwibm90IiwiZW51bSIsImFueU9mIiwicmVxdWlyZWQiLCJjcmVhdGUiLCJvcHRpb25zIiwiZ2V0RmlsZW5hbWUiLCJjaGVja0V4cG9ydFByZXNlbmNlIiwibm9kZSIsImV4cG9ydENvdW50IiwibmFtZXNwYWNlSW1wb3J0cyIsImRlbGV0ZSIsInNpemUiLCJyZXBvcnQiLCJib2R5IiwiY2hlY2tVc2FnZSIsImV4cG9ydGVkVmFsdWUiLCJleHBvcnRzS2V5IiwidXBkYXRlRXhwb3J0VXNhZ2UiLCJuZXdFeHBvcnRzIiwibmV3RXhwb3J0SWRlbnRpZmllcnMiLCJsZW5ndGgiLCJleHBvcnRlZCIsInVwZGF0ZUltcG9ydFVzYWdlIiwib2xkSW1wb3J0UGF0aHMiLCJvbGROYW1lc3BhY2VJbXBvcnRzIiwibmV3TmFtZXNwYWNlSW1wb3J0cyIsIm9sZEV4cG9ydEFsbCIsIm5ld0V4cG9ydEFsbCIsIm9sZERlZmF1bHRJbXBvcnRzIiwibmV3RGVmYXVsdEltcG9ydHMiLCJvbGRJbXBvcnRzIiwibmV3SW1wb3J0cyIsImFzdE5vZGUiLCJyZXNvbHZlZFBhdGgiLCJzb3VyY2UiLCJyYXciLCJyZXBsYWNlIiwiaW1wb3J0ZWQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQU1BLHlDO0FBQ0E7QUFDQSxzRDtBQUNBLHFDO0FBQ0E7QUFDQSx3QztBQUNBLHVDO0FBQ0EsK0MsbVZBYkE7Ozs7c1lBZUE7QUFDQTtBQUNBLElBQUlBLGtCQUFKLENBQ0EsSUFBSSxDQUNGLE1BQU1DLGlCQUFpQkMsUUFBUSx1Q0FBUixFQUFpREQsY0FBeEU7QUFDQUQsdUJBQXFCLFVBQVVHLEdBQVYsRUFBZUMsVUFBZixFQUEyQjtBQUM5QyxVQUFNQyxJQUFJLElBQUlKLGNBQUosQ0FBbUI7QUFDM0JHLGtCQUFZQSxVQURlLEVBQW5CLENBQVY7O0FBR0EsV0FBT0UsTUFBTUMsSUFBTixD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cEYsSUFBL0I7QUFDRDtBQUNGO0FBQ0Y7QUFDRixPQWJEO0FBY0QsS0FyUUQ7O0FBdVFBLFdBQU87QUFDTCxzQkFBZ0JpRixRQUFRO0FBQ3RCVSwwQkFBa0JWLElBQWxCO0FBQ0FlLDBCQUFrQmYsSUFBbEI7QUFDQUQsNEJBQW9CQyxJQUFwQjtBQUNELE9BTEk7QUFNTCxrQ0FBNEJBLFFBQVE7QUFDbENPLG1CQUFXUCxJQUFYLEVBQWlCdEgsd0JBQWpCO0FBQ0QsT0FSSTtBQVNMLGdDQUEwQnNILFFBQVE7QUFDaENBLGFBQUt0QyxVQUFMLENBQWdCL0QsT0FBaEIsQ0FBd0JrRCxhQUFhO0FBQ2pDMEQscUJBQVdQLElBQVgsRUFBaUJuRCxVQUFVaUUsUUFBVixDQUFtQnJILElBQXBDO0FBQ0gsU0FGRDtBQUdBTCxxQ0FBNkI0RyxLQUFLM0csV0FBbEMsRUFBZ0RJLElBQUQsSUFBVTtBQUN2RDhHLHFCQUFXUCxJQUFYLEVBQWlCdkcsSUFBakI7QUFDRCxTQUZEO0FBR0QsT0FoQkksRUFBUDs7QUFrQkQsR0E1Z0JjLEVBQWpCIiwiZmlsZSI6Im5vLXVudXNlZC1tb2R1bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEVuc3VyZXMgdGhhdCBtb2R1bGVzIGNvbnRhaW4gZXhwb3J0cyBhbmQvb3IgYWxsXG4gKiBtb2R1bGVzIGFyZSBjb25zdW1lZCB3aXRoaW4gb3RoZXIgbW9kdWxlcy5cbiAqIEBhdXRob3IgUmVuw6kgRmVybWFublxuICovXG5cbmltcG9ydCBFeHBvcnRzIGZyb20gJy4uL0V4cG9ydE1hcCdcbmltcG9ydCB7IGdldEZpbGVFeHRlbnNpb25zIH0gZnJvbSAnZXNsaW50LW1vZHVsZS11dGlscy9pZ25vcmUnXG5pbXBvcnQgcmVzb2x2ZSBmcm9tICdlc2xpbnQtbW9kdWxlLXV0aWxzL3Jlc29sdmUnXG5pbXBvcnQgZG9jc1VybCBmcm9tICcuLi9kb2NzVXJsJ1xuaW1wb3J0IHsgZGlybmFtZSwgam9pbiB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgcmVhZFBrZ1VwIGZyb20gJ3JlYWQtcGtnLXVwJ1xuaW1wb3J0IHZhbHVlcyBmcm9tICdvYmplY3QudmFsdWVzJ1xuaW1wb3J0IGluY2x1ZGVzIGZyb20gJ2FycmF5LWluY2x1ZGVzJ1xuXG4vLyBlc2xpbnQvbGliL3V0aWwvZ2xvYi11dGlsIGhhcyBiZWVuIG1vdmVkIHRvIGVzbGludC9saWIvdXRpbC9nbG9iLXV0aWxzIHdpdGggdmVyc2lvbiA1LjNcbi8vIGFuZCBoYXMgYmVlbiBtb3ZlZCB0byBlc2xpbnQvbGliL2NsaS1lbmdpbmUvZmlsZS1lbnVtZXJhdG9yIGluIHZlcnNpb24gNlxubGV0IGxpc3RGaWxlc1RvUHJvY2Vzc1xudHJ5IHtcbiAgY29uc3QgRmlsZUVudW1lcmF0b3IgPSByZXF1aXJlKCdlc2xpbnQvbGliL2NsaS1lbmdpbmUvZmlsZS1lbnVtZXJhdG9yJykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdEZpbGVzVG9Qcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgZXh0ZW5zaW9ucykge1xuI